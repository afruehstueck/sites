<!DOCTYPE html>
<html>
<head>
  <title>Experimental GLSL Image Processing</title>
  <link rel="stylesheet" href="glimp.css" />
  <script src='jquery-1.11.0.min.js'></script>
</head>

<body>

<h1>GLSL Registration Demo</h1>

<a href="./index.html"><- Return to Experimental GLSL Image Processing</a>

<p>
Experimental nonlinear registration
</p>

<h2>Deformation and Composite buffers</h2>
<canvas id='compositeCanvas' class='drawable'></canvas>
<canvas id='deformationCanvas' class='drawable'></canvas>

<table id='parameters'>
  <tr>
    <th style="text-align:left">Number of Iterations</th>
  </tr><tr>
    <td><input type="range" min="1" max="300" value="1" step="1" id="numberOfIterations"></td>
  </tr><tr>
    <th style="text-align:left">Image Weight</th>
  </tr><tr>
    <td><input type="range" min="0" max="100" value="0" step="1" id="imageWeight"></td>
  </tr>
  </tr><tr>
    <th style="text-align:left">Regularizer Weight</th>
  </tr><tr>
  </tr><tr>
    <td><input type="range" min="0" max="100" value="0" step="1" id="regularizerWeight"></td>
  </tr>
</table>

<h2>Moving and Fixed Images</h2>
<img id="moving" class='drawable' src="./preOpT2.png" ></img>
<img id="fixed" class='drawable' src="./intraOpT2.png" ></img>
<!--
<img id="fixed" class='drawable' src="./preOpT2.png" ></img>
-->

<p>
</p>



<script id="vertexShader" type="x-shader/x-vertex">
precision highp float;

attribute vec3 coordinate;
attribute vec2 textureCoordinate;

varying vec2 varyingTextureCoordinate;

void main(void) {
  gl_Position = vec4(coordinate,1.);
  varyingTextureCoordinate = textureCoordinate;
}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
precision highp float;

// Deformation filter.
//

uniform sampler2D movingTextureSampler;
uniform sampler2D fixedTextureSampler;
uniform sampler2D deformationTextureSampler;
uniform vec2 movingTextureSize;
uniform vec2 movingTexelSize;
uniform vec2 fixedTextureSize;
uniform vec2 fixedTexelSize;
uniform vec2 focusPoint;
uniform int iteration;
uniform int numberOfIterations;
uniform float imageWeight;
uniform float regularizerWeight;

varying vec2 varyingTextureCoordinate;

void main(void) {

  vec4 fixedColor = texture2D(fixedTextureSampler, varyingTextureCoordinate);
  vec4 deformation = texture2D(deformationTextureSampler, varyingTextureCoordinate);

  //r = dx, b = dy, g = theta, a = bias
  float translationGain = 1.;
  vec2 translation = (deformation.rg - vec2(0.5)) * movingTexelSize;

  if ( iteration == numberOfIterations  -   1 ) {

    vec4 movingColor = texture2D(movingTextureSampler, varyingTextureCoordinate + translation/movingTexelSize);

    // final render
    // show checkerboard of fixed and deformed moving
    bool checkerboard = false;
    if (checkerboard) {
      if ( varyingTextureCoordinate.x < focusPoint.x ) {
        if ( varyingTextureCoordinate.y < focusPoint.y ) {
          gl_FragColor = fixedColor;
        } else {
          gl_FragColor = movingColor;
        }
      } else {
        if ( varyingTextureCoordinate.y > focusPoint.y ) {
          gl_FragColor = fixedColor;
        } else {
          gl_FragColor = movingColor;
        }
      }
    } else {
      gl_FragColor = vec4(movingColor.r, movingColor.r, movingColor.r, 1);
    }
  } else {

    //
    vec2 regularizedTranslation = 0.5 * translation;
    for (int i=-1; i <= 1; i += 2) {
      for (int j=-1; j <= 1; j += 2) {
        vec2 neighborDirection = vec2(i,j) * movingTexelSize;
        vec4 neighborDeformation = texture2D(deformationTextureSampler, varyingTextureCoordinate + neighborDirection);
        vec2 neighborTranslation = (neighborDeformation.rg - vec2(0.5)) * movingTexelSize;
        regularizedTranslation = regularizedTranslation + .125 * neighborTranslation;
      }
    }

    vec3 originalMovingRGB = texture2D(movingTextureSampler, varyingTextureCoordinate).rgb;
    vec3 currentGuessRGB = texture2D(fixedTextureSampler, varyingTextureCoordinate+regularizedTranslation).rgb;
    float currentDifference = abs(currentGuessRGB.r - originalMovingRGB.r);
    vec2 imagePull = vec2(0.);
    for (int i=-1; i <= 1; i += 2) {
      for (int j=-1; j <= 1; j += 2) {
        vec2 neighborDirection = vec2(i,j) * movingTexelSize;
        vec2 neighbor = varyingTextureCoordinate + translation + neighborDirection;
        vec3 neighborRGB = texture2D(fixedTextureSampler, neighbor).rgb;
        float neighborDifference = abs(neighborRGB.r-originalMovingRGB.r);
        float neighborWeight = (1. - abs(neighborDifference - currentDifference));
        imagePull = imagePull + .05 * neighborWeight * neighborDirection;
      }
    }

    vec2 newTranslation = (1.-imageWeight) * regularizedTranslation + imageWeight * imagePull;
    gl_FragColor = vec4(clamp((newTranslation / movingTexelSize) + vec2(0.5), 0., .9999), currentGuessRGB.r, 1.);

    //gl_FragColor = vec4(clamp((regularizedTranslation / movingTexelSize) + vec2(0.5), 0., .9999), currentDifference, 1.);
    //gl_FragColor = vec4(clamp((imagePull + vec2(0.5)) / translationGain, 0., .9999), currentDifference, 1.);
  }
}

</script>

<script>
'use strict'

var focusPoint = [0., 0.99]; // holds a value to be passed as a uniform to the shader
var movingTextureSize = [0,0];
var fixedTextureSize = [0,0];
var numberOfIterations = 1;
var imageWeight = 0.;
var regularizerWeight = 0.;


//
// set up webgl
//
var compositeCanvas = document.querySelector('#compositeCanvas');
var compositeContext = compositeCanvas.getContext('webgl');
compositeContext.clearColor(0.0, 0.0, 0.0, 1.0); // black, fully opaque
compositeContext.enable(compositeContext.DEPTH_TEST);
compositeContext.depthFunc(compositeContext.LEQUAL); // Near things obscure far things

// buffers for the textured plane in normalized space
var renderImageCoordinatesBuffer = compositeContext.createBuffer();
var renderImageTexureCoordinatesBuffer = compositeContext.createBuffer();
var renderImageVertices = [ -1., -1., 0., 1., -1., 0., -1.,  1., 0., 1.,  1., 0., ];
compositeContext.bindBuffer(compositeContext.ARRAY_BUFFER, renderImageCoordinatesBuffer);
compositeContext.bufferData(compositeContext.ARRAY_BUFFER, new Float32Array(renderImageVertices), compositeContext.STATIC_DRAW);

var renderImageTextureCoordinates = [ 0, 0,  1, 0,  0, 1,  1, 1 ];
compositeContext.bindBuffer(compositeContext.ARRAY_BUFFER, renderImageTexureCoordinatesBuffer);
compositeContext.bufferData(compositeContext.ARRAY_BUFFER, new Float32Array(renderImageTextureCoordinates), compositeContext.STATIC_DRAW);

// the fixed and moving textures
var movingTextureImage;
var movingTexture = compositeContext.createTexture();
var fixedTextureImage;
var fixedTexture = compositeContext.createTexture();
var setupSourceTextures = function() {
  compositeContext.activeTexture(compositeContext.TEXTURE0);
  compositeContext.bindTexture(compositeContext.TEXTURE_2D, movingTexture);
  compositeContext.pixelStorei(compositeContext.UNPACK_FLIP_Y_WEBGL, true);
  compositeContext.texImage2D(compositeContext.TEXTURE_2D, 0, compositeContext.RGBA, compositeContext.RGBA, compositeContext.UNSIGNED_BYTE, movingTextureImage);
  compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_MAG_FILTER, compositeContext.LINEAR);
  compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_MIN_FILTER, compositeContext.LINEAR);
  compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_WRAP_S, compositeContext.CLAMP_TO_EDGE);
  compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_WRAP_T, compositeContext.CLAMP_TO_EDGE);

  movingTextureSize[0] = movingTextureImage.width;
  movingTextureSize[1] = movingTextureImage.height;

  compositeContext.activeTexture(compositeContext.TEXTURE1);
  compositeContext.bindTexture(compositeContext.TEXTURE_2D, fixedTexture);
  compositeContext.pixelStorei(compositeContext.UNPACK_FLIP_Y_WEBGL, true);
  compositeContext.texImage2D(compositeContext.TEXTURE_2D, 0, compositeContext.RGBA, compositeContext.RGBA, compositeContext.UNSIGNED_BYTE, fixedTextureImage);
  compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_MAG_FILTER, compositeContext.LINEAR);
  compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_MIN_FILTER, compositeContext.LINEAR);
  compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_WRAP_S, compositeContext.CLAMP_TO_EDGE);
  compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_WRAP_T, compositeContext.CLAMP_TO_EDGE);

  fixedTextureSize[0] = fixedTextureImage.width;
  fixedTextureSize[1] = fixedTextureImage.height;
};

// the initial deformation texture
var deformationTextureImage;
var deformationTexture = compositeContext.createTexture();
var setupInitialDeformationTexture = function() {
  compositeContext.activeTexture(compositeContext.TEXTURE2);
  compositeContext.bindTexture(compositeContext.TEXTURE_2D, deformationTexture);
  compositeContext.pixelStorei(compositeContext.UNPACK_FLIP_Y_WEBGL, true);
  compositeContext.texImage2D(compositeContext.TEXTURE_2D, 0, compositeContext.RGBA, compositeContext.RGBA, compositeContext.UNSIGNED_BYTE, deformationTextureImage);
  compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_MAG_FILTER, compositeContext.LINEAR);  // jvm - do we want nearest of linear?
  compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_MIN_FILTER, compositeContext.LINEAR);
  compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_WRAP_S, compositeContext.CLAMP_TO_EDGE);
  compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_WRAP_T, compositeContext.CLAMP_TO_EDGE);
};

// extra textures and framebuffers for intermediate results of iterative filters and pipelines
var textures = [];
var framebuffers = [];
var setupFrameBuffers = function() {
  for (var ii = 0; ii < 2; ++ii) {
      // create a texture for the framebuffer
      var texture = compositeContext.createTexture();
      compositeContext.bindTexture(compositeContext.TEXTURE_2D, texture);
      compositeContext.texImage2D(compositeContext.TEXTURE_2D, 0, compositeContext.RGBA, movingTextureImage.width, movingTextureImage.height, 0,
        compositeContext.RGBA, compositeContext.UNSIGNED_BYTE, null);
      compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_MAG_FILTER, compositeContext.LINEAR);
      compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_MIN_FILTER, compositeContext.LINEAR);
      compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_WRAP_S, compositeContext.CLAMP_TO_EDGE);
      compositeContext.texParameteri(compositeContext.TEXTURE_2D, compositeContext.TEXTURE_WRAP_T, compositeContext.CLAMP_TO_EDGE);
      textures.push(texture);

      // create a framebuffer
      var fbo = compositeContext.createFramebuffer();
      framebuffers.push(fbo);
      compositeContext.bindFramebuffer(compositeContext.FRAMEBUFFER, fbo);
      compositeContext.clearColor(0.0, 0.0, 0.0, 1.0);

      // attach texture to frame buffer
      compositeContext.framebufferTexture2D(compositeContext.FRAMEBUFFER, compositeContext.COLOR_ATTACHMENT0, compositeContext.TEXTURE_2D, texture, 0);
      compositeContext.clear(compositeContext.COLOR_BUFFER_BIT);
   }
}

// the program and shaders
var glProgram = compositeContext.createProgram();
var vertexShader = compositeContext.createShader(compositeContext.VERTEX_SHADER);
compositeContext.shaderSource(vertexShader, document.getElementById("vertexShader").innerHTML);
compositeContext.compileShader(vertexShader);
if (!compositeContext.getShaderParameter(vertexShader, compositeContext.COMPILE_STATUS)) {
  alert('Could not compile vertexShader');
  console.log(compositeContext.getShaderInfoLog(vertexShader));
}
var fragmentShader = compositeContext.createShader(compositeContext.FRAGMENT_SHADER);
compositeContext.shaderSource(fragmentShader, document.getElementById("fragmentShader").innerHTML);
compositeContext.compileShader(fragmentShader);
if (!compositeContext.getShaderParameter(fragmentShader, compositeContext.COMPILE_STATUS)) {
  alert('Could not compile fragmentShader');
  console.log(compositeContext.getShaderInfoLog(fragmentShader));
}
compositeContext.attachShader(glProgram, vertexShader);
compositeContext.deleteShader(vertexShader);
compositeContext.attachShader(glProgram, fragmentShader);
compositeContext.deleteShader(fragmentShader);
compositeContext.linkProgram(glProgram);

// render a frame
function render() {
  compositeContext.viewport(0, 0, compositeCanvas.width, compositeCanvas.height);
  compositeContext.clear(compositeContext.COLOR_BUFFER_BIT|compositeContext.DEPTH_BUFFER_BIT);

  compositeContext.useProgram(glProgram);

  // Buffers

  // the coordinate attribute
  compositeContext.bindBuffer(compositeContext.ARRAY_BUFFER, renderImageCoordinatesBuffer);
  var coordinateLocation = compositeContext.getAttribLocation(glProgram, "coordinate");
  compositeContext.enableVertexAttribArray( coordinateLocation );
  compositeContext.vertexAttribPointer( coordinateLocation, 3, compositeContext.FLOAT, false, 0, 0);

  // the textureCoordinate attribute
  compositeContext.bindBuffer(compositeContext.ARRAY_BUFFER, renderImageTexureCoordinatesBuffer);
  var textureCoordinateLocation = compositeContext.getAttribLocation(glProgram, "textureCoordinate");
  compositeContext.enableVertexAttribArray( textureCoordinateLocation );
  compositeContext.vertexAttribPointer( textureCoordinateLocation, 2, compositeContext.FLOAT, false, 0, 0);

  // Uniforms

  compositeContext.uniform1i(compositeContext.getUniformLocation(glProgram, "numberOfIterations"), numberOfIterations);

  compositeContext.uniform1f(compositeContext.getUniformLocation(glProgram, "imageWeight"), imageWeight);

  compositeContext.uniform1f(compositeContext.getUniformLocation(glProgram, "regularizerWeight"), regularizerWeight);

  // set up the focus point (pointer position)
  compositeContext.uniform2f(compositeContext.getUniformLocation(glProgram, "focusPoint"), focusPoint[0], focusPoint[1]);

  // set up the movingTextureSize
  compositeContext.uniform2f(compositeContext.getUniformLocation(glProgram, "movingTextureSize"), movingTextureSize[0], movingTextureSize[1]);

  // set up the movingTexelSize
  compositeContext.uniform2f(compositeContext.getUniformLocation(glProgram, "movingTexelSize"), 1.0/movingTextureSize[0], 1.0/movingTextureSize[1]);

  // set up the fixedTextureSize
  compositeContext.uniform2f(compositeContext.getUniformLocation(glProgram, "fixedTextureSize"), fixedTextureSize[0], fixedTextureSize[1]);

  // set up the fixedTexelSize
  compositeContext.uniform2f(compositeContext.getUniformLocation(glProgram, "fixedTexelSize"), 1.0/fixedTextureSize[0], 1.0/fixedTextureSize[1]);

  // Textures

  // the movingTexture
  compositeContext.activeTexture(compositeContext.TEXTURE0);  // bind movingTexture to texture unit 0
  compositeContext.bindTexture(compositeContext.TEXTURE_2D, movingTexture);
  compositeContext.uniform1i(compositeContext.getUniformLocation(glProgram, "movingTextureSampler"), 0); // then, assign movingTextureSampler to this texture unit

  // the fixedTexture
  compositeContext.activeTexture(compositeContext.TEXTURE1);  // bind fixedTextureSampler to texture unit 1
  compositeContext.bindTexture(compositeContext.TEXTURE_2D, fixedTexture);
  compositeContext.uniform1i(compositeContext.getUniformLocation(glProgram, "fixedTextureSampler"), 1); // then, assign fixedTextureSampler to this texture unit

  // the deformationTexture
  compositeContext.activeTexture(compositeContext.TEXTURE2);  // bind deformationTexture to texture unit 2
  compositeContext.bindTexture(compositeContext.TEXTURE_2D, deformationTexture);
  compositeContext.uniform1i(compositeContext.getUniformLocation(glProgram, "deformationTextureSampler"), 2);

  var iteration;
  for (iteration = 0; iteration < numberOfIterations; ++iteration)
  {
    compositeContext.uniform1i(compositeContext.getUniformLocation(glProgram, "iteration"), iteration);

    // set the frame buffer to render into
    if (iteration == numberOfIterations-1) {
      // use the canvas frame buffer for final render
      compositeContext.bindFramebuffer(compositeContext.FRAMEBUFFER, null);
    } else {
      // render into one of the texture framebuffers
      compositeContext.bindFramebuffer(compositeContext.FRAMEBUFFER, framebuffers[iteration%2]);
    }

    // the primitive, triggers the fragment shader
    compositeContext.drawArrays(compositeContext.TRIANGLE_STRIP, 0, 4);

    // switch the intermediate texture for next render
    compositeContext.activeTexture(compositeContext.TEXTURE2); // Use TEXTURE2 as the intermediate image for deforming
    compositeContext.bindTexture(compositeContext.TEXTURE_2D, textures[iteration%2]);
  }
}

function setupInterface() {

  //
  // set up the compositeCanvas
  //
  var moving = $('#moving')[0];
  var fixed = $('#fixed')[0];
  var compositeCanvas = $('#compositeCanvas')[0];
  compositeCanvas.width = fixed.width;
  compositeCanvas.height = fixed.height;
  var deformationCanvas = $('#deformationCanvas')[0];
  deformationCanvas.width = fixed.width;
  deformationCanvas.height = fixed.height;
  var deformationContext = deformationCanvas.getContext("2d");
  deformationContext.fillStyle = "rgba(0,0,0,1)";
  deformationContext.fillRect(0,0,deformationCanvas.width,deformationCanvas.height);
  var gradient = deformationContext.createRadialGradient(100, 100, 0, 100, 100, 400);
  gradient.addColorStop(0, 'white');
  gradient.addColorStop(.1, 'black');
  gradient.addColorStop(.2, 'white');
  gradient.addColorStop(1, 'purple');
  deformationContext.fillStyle = gradient;
  deformationContext.fillStyle = "#777777";
  deformationContext.fillRect(3,5,deformationCanvas.width/1.2,deformationCanvas.height-100);
  console.log('filled');

  $('#numberOfIterations').width(deformationCanvas.width);
  $('#imageWeight').width(deformationCanvas.width);
  $('#regularizerWeight').width(deformationCanvas.width);

  function recalculateDeformation() {
    movingTextureImage = $('#moving')[0];
    fixedTextureImage = $('#fixed')[0];
    deformationTextureImage = new Image();
    deformationTextureImage.src = deformationCanvas.toDataURL("image/png");
    setupInitialDeformationTexture(); // jvm - changes these to take image as parameter? change these to keep things as fields in image[i]?
    setupSourceTextures(); // jvm - changes these to take image as parameter? change these to keep things as fields in image[i]?
    setupFrameBuffers();
    compositeCanvas.height = movingTextureImage.height;
    compositeCanvas.width = movingTextureImage.width;
    render();
  };
  recalculateDeformation();

  // pass the mouse location as a uniform variable to the fragment shader
  var updateFocus = function(event) {
    var movingImage = $('#moving')[0];
    focusPoint = [event.offsetX / movingImage.width, 1. - (event.offsetY / movingImage.height)];
    render();
  };
  $('#compositeCanvas').mousedown(updateFocus);
  $('#compositeCanvas').mousemove(updateFocus);
  $('#compositeCanvas').mouseout(updateFocus);

  var drawStyle = "#F00";
  var drawing=false;
  function drawPoint (event) {
    if (drawing) {
      drawContext.strokeStyle = drawStyle;
      drawContext.fillStyle = drawStyle;
      drawContext.beginPath();
      drawContext.arc(event.offsetX, event.offsetY, 3, 0,2*Math.PI);
      drawContext.stroke();
      drawContext.fill();
      //redrawCompositeImage();
    }
  }
  $('.drawable').mousedown(function(event) {
    drawing=true;
    drawPoint(event);
  });
  $('.drawable').mousemove(function(event) {
    event.preventDefault();
    drawPoint(event);
    var continuousMode = true;
    if (continuousMode == true) {
      //redrawCompositeImage();
      recalculateDeformation();
    }
  });
  $('.drawable').mouseup(function(event) {
    drawing=false;
    recalculateDeformation();
  });
  $('.drawable').mouseout(function(event) {
    drawing=false;
    recalculateDeformation();
  });

  //
  // user interface elements
  //
  function updateParameters() {
    numberOfIterations = Number(document.getElementById('numberOfIterations').value);
    imageWeight = Number(document.getElementById('imageWeight').value) / 100.;
    regularizerWeight = Number(document.getElementById('regularizerWeight').value) / 100.;
    render();
  }

  // listen to continuous and release events
  // http://stackoverflow.com/questions/18544890/onchange-event-on-input-type-range-is-not-triggering-in-firefox-while-dragging
  document.getElementById('numberOfIterations').onchange = updateParameters;
  document.getElementById('imageWeight').onchange = updateParameters;
  document.getElementById('regularizerWeight').onchange = updateParameters;
  document.getElementById('numberOfIterations').oninput = updateParameters;
  document.getElementById('imageWeight').oninput = updateParameters;
  document.getElementById('regularizerWeight').oninput = updateParameters;
}

// once document is loaded, then load images, set up textures and framebuffers, and render
$(function () {
  /*
  var imagesLoaded = 0;
  function imageLoaded() {
    imagesLoaded++;
    console.log('loaded', imagesLoaded);
    if (imagesLoaded == 2) {
    }
  }
  $('#moving').load(imageLoaded);
  $('#fixed').load(imageLoaded);
  */

  setupInterface();
});

</script>

<p>
Move pointer over the lower image. To the left of the mouse, the original intensity image is displayed with the pixels recolored to show the segmentation.
<br>
To the right of the mouse, the segmentation is shown above the mouse, while the strength image is shown below.
<br><br>
Check out <a href='https://github.com/pieper/sites/tree/gh-pages/glimp'>the source code</a>.
</p>

<p>
This demo uses WebGL.  Not all devices and browsers are supported.
</p>

</body>
</html>
