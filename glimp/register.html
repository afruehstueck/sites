<!DOCTYPE html>
<html>
<head>
  <title>Experimental GLSL Image Processing</title>
  <link rel="stylesheet" href="glimp.css" />
  <script src='jquery-1.11.0.min.js'></script>
</head>

<body>

<h1>GLSL Registration Demo</h1>

<a href="./index.html"><- Return to Experimental GLSL Image Processing</a>

<p>
Experimental nonlinear registration
</p>

<h2>Deformation and Composite buffers</h2>
<canvas id='compositeCanvas' class='drawable'></canvas>
<canvas id='deformationCanvas' class='drawable'></canvas>

<table id='parameters'>
  <tr>
    <th style="text-align:left">Number of Iterations</th>
  </tr><tr>
    <td><input type="range" min="1" max="3000" value="300" step="2" id="numberOfIterations"></td>
  </tr><tr>
    <th style="text-align:left">Weight</th>
  </tr><tr>
    <td><input type="range" min="0" max="200" value="10" step="1" id="weight"></td>
  </tr>
</table>

<h2>Moving and Fixed Images</h2>
<img id="moving" class='drawable' src="./preOpT2.png" ></img>
<img id="fixed" class='drawable' src="./intraOpT2.png" ></img>

<p>
</p>



<script id="vertexShader" type="x-shader/x-vertex">
precision highp float;

attribute vec3 coordinate;
attribute vec2 textureCoordinate;

varying vec2 varyingTextureCoordinate;

void main(void) {
  gl_Position = vec4(coordinate,1.);
  varyingTextureCoordinate = textureCoordinate;
}
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
precision highp float;

// Deformation filter.
//

uniform sampler2D movingTextureSampler;
uniform sampler2D fixedTextureSampler;
uniform sampler2D deformationTextureSampler;
uniform vec2 movingTextureSize;
uniform vec2 movingTexelSize;
uniform vec2 fixedTextureSize;
uniform vec2 fixedTexelSize;
uniform vec2 focusPoint;
uniform int iteration;
uniform int numberOfIterations;

varying vec2 varyingTextureCoordinate;

void main(void) {

  vec4 fixedColor = texture2D(fixedTextureSampler, varyingTextureCoordinate);
  vec4 deformation = texture2D(deformationTextureSampler, varyingTextureCoordinate);

  //r = dx, b = dy, g = theta, a = bias
  float translationGain = .1;
  vec2 translation = deformation.rb * translationGain;

  vec4 movingColor = texture2D(movingTextureSampler, varyingTextureCoordinate + translation);



  if ( iteration == numberOfIterations-1 ) {
    // final render
    // show checkerboard of fixed and deformed moving
    if ( varyingTextureCoordinate.x < focusPoint.x ) {
      if ( varyingTextureCoordinate.y < focusPoint.y ) {
        gl_FragColor = fixedColor;
      } else {
        gl_FragColor = movingColor;
      }
    } else {
      if ( varyingTextureCoordinate.y > focusPoint.y ) {
        gl_FragColor = fixedColor;
      } else {
        gl_FragColor = movingColor;
      }
    }
  } else {
    // output new deformation
    gl_FragColor = deformation = deformation * 1.01;

  }

}

</script>

<script>
'use strict'

var focusPoint = [0., 0.99]; // holds a value to be passed as a uniform to the shader
var movingTextureSize = [0,0];
var fixedTextureSize = [0,0];
var numberOfIterations = 10;
var weight = 1;


//
// set up webgl
//
var compositeCanvas = document.querySelector('#compositeCanvas');
var gl = compositeCanvas.getContext('webgl');
gl.clearColor(0.0, 0.0, 0.0, 1.0); // black, fully opaque
gl.enable(gl.DEPTH_TEST);
gl.depthFunc(gl.LEQUAL); // Near things obscure far things

// buffers for the textured plane in normalized space
var renderImageCoordinatesBuffer = gl.createBuffer();
var renderImageTexureCoordinatesBuffer = gl.createBuffer();
var renderImageVertices = [ -1., -1., 0., 1., -1., 0., -1.,  1., 0., 1.,  1., 0., ];
gl.bindBuffer(gl.ARRAY_BUFFER, renderImageCoordinatesBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderImageVertices), gl.STATIC_DRAW);

var renderImageTextureCoordinates = [ 0, 0,  1, 0,  0, 1,  1, 1 ];
gl.bindBuffer(gl.ARRAY_BUFFER, renderImageTexureCoordinatesBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderImageTextureCoordinates), gl.STATIC_DRAW);

// the fixed and moving textures
var movingTextureImage;
var movingTexture = gl.createTexture();
var fixedTextureImage;
var fixedTexture = gl.createTexture();
var setupSourceTextures = function() {
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, movingTexture);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, movingTextureImage);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  movingTextureSize[0] = movingTextureImage.width;
  movingTextureSize[1] = movingTextureImage.height;

  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, fixedTexture);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, fixedTextureImage);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  fixedTextureSize[0] = fixedTextureImage.width;
  fixedTextureSize[1] = fixedTextureImage.height;
};

// the initial deformation texture
var deformationTextureImage;
var deformationTexture = gl.createTexture();
var setupInitialDeformationTexture = function() {
  gl.activeTexture(gl.TEXTURE2);
  gl.bindTexture(gl.TEXTURE_2D, deformationTexture);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, deformationTextureImage);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);  // jvm - do we want nearest of linear?
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
};

// extra textures and framebuffers for intermediate results of iterative filters and pipelines
var textures = [];
var framebuffers = [];
var setupFrameBuffers = function() {
  for (var ii = 0; ii < 2; ++ii) {
      // create a texture for the framebuffer
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, movingTextureImage.width, movingTextureImage.height, 0,
        gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      textures.push(texture);

      // create a framebuffer
      var fbo = gl.createFramebuffer();
      framebuffers.push(fbo);
      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
      gl.clearColor(0.0, 0.0, 0.0, 1.0);

      // attach texture to frame buffer
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
   }
}

// the program and shaders
var glProgram = gl.createProgram();
var vertexShader = gl.createShader(gl.VERTEX_SHADER);
gl.shaderSource(vertexShader, document.getElementById("vertexShader").innerHTML);
gl.compileShader(vertexShader);
if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
  alert('Could not compile vertexShader');
  console.log(gl.getShaderInfoLog(vertexShader));
}
var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
gl.shaderSource(fragmentShader, document.getElementById("fragmentShader").innerHTML);
gl.compileShader(fragmentShader);
if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
  alert('Could not compile fragmentShader');
  console.log(gl.getShaderInfoLog(fragmentShader));
}
gl.attachShader(glProgram, vertexShader);
gl.deleteShader(vertexShader);
gl.attachShader(glProgram, fragmentShader);
gl.deleteShader(fragmentShader);
gl.linkProgram(glProgram);

// render a frame
function render() {
  gl.viewport(0, 0, compositeCanvas.width, compositeCanvas.height);
  gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

  gl.useProgram(glProgram);

  // Buffers

  // the coordinate attribute
  gl.bindBuffer(gl.ARRAY_BUFFER, renderImageCoordinatesBuffer);
  var coordinateLocation = gl.getAttribLocation(glProgram, "coordinate");
  gl.enableVertexAttribArray( coordinateLocation );
  gl.vertexAttribPointer( coordinateLocation, 3, gl.FLOAT, false, 0, 0);

  // the textureCoordinate attribute
  gl.bindBuffer(gl.ARRAY_BUFFER, renderImageTexureCoordinatesBuffer);
  var textureCoordinateLocation = gl.getAttribLocation(glProgram, "textureCoordinate");
  gl.enableVertexAttribArray( textureCoordinateLocation );
  gl.vertexAttribPointer( textureCoordinateLocation, 2, gl.FLOAT, false, 0, 0);

  // Uniforms

  gl.uniform1i(gl.getUniformLocation(glProgram, "numberOfIterations"), numberOfIterations);

  // set up the focus point (pointer position)
  gl.uniform2f(gl.getUniformLocation(glProgram, "focusPoint"), focusPoint[0], focusPoint[1]);

  // set up the movingTextureSize
  gl.uniform2f(gl.getUniformLocation(glProgram, "movingTextureSize"), movingTextureSize[0], movingTextureSize[1]);

  // set up the movingTexelSize
  gl.uniform2f(gl.getUniformLocation(glProgram, "movingTexelSize"), 1.0/movingTextureSize[0], 1.0/movingTextureSize[1]);

  // set up the fixedTextureSize
  gl.uniform2f(gl.getUniformLocation(glProgram, "fixedTextureSize"), fixedTextureSize[0], fixedTextureSize[1]);

  // set up the fixedTexelSize
  gl.uniform2f(gl.getUniformLocation(glProgram, "fixedTexelSize"), 1.0/fixedTextureSize[0], 1.0/fixedTextureSize[1]);

  // Textures

  // the movingTexture
  gl.activeTexture(gl.TEXTURE0);  // bind movingTexture to texture unit 0
  gl.bindTexture(gl.TEXTURE_2D, movingTexture);
  gl.uniform1i(gl.getUniformLocation(glProgram, "movingTextureSampler"), 0); // then, assign movingTextureSampler to this texture unit

  // the fixedTexture
  gl.activeTexture(gl.TEXTURE1);  // bind fixedTextureSampler to texture unit 1
  gl.bindTexture(gl.TEXTURE_2D, fixedTexture);
  gl.uniform1i(gl.getUniformLocation(glProgram, "fixedTextureSampler"), 1); // then, assign fixedTextureSampler to this texture unit

  // the deformationTexture
  gl.activeTexture(gl.TEXTURE2);  // bind deformationTexture to texture unit 2
  gl.bindTexture(gl.TEXTURE_2D, deformationTexture);
  gl.uniform1i(gl.getUniformLocation(glProgram, "deformationTextureSampler"), 2);

  var iteration;
  for (iteration = 0; iteration < numberOfIterations; ++iteration)
  {
    gl.uniform1i(gl.getUniformLocation(glProgram, "iteration"), iteration);

    // set the frame buffer to render into
    if (iteration == numberOfIterations-1) {
      // use the canvas frame buffer for final render
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    } else {
      // render into one of the texture framebuffers
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[iteration%2]);
    }

    // the primitive, triggers the fragment shader
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // switch the intermediate texture for next render
    gl.activeTexture(gl.TEXTURE2); // Use TEXTURE2 as the intermediate image for deforming
    gl.bindTexture(gl.TEXTURE_2D, textures[iteration%2]);
  }
}

function setupInterface() {

  //
  // set up the compositeCanvas
  //
  var moving = $('#moving')[0];
  var fixed = $('#fixed')[0];
  var compositeCanvas = $('#compositeCanvas')[0];
  compositeCanvas.width = fixed.width;
  compositeCanvas.height = fixed.height;
  var deformationCanvas = $('#deformationCanvas')[0];
  deformationCanvas.width = fixed.width;
  deformationCanvas.height = fixed.height;
  var deformationContext = deformationCanvas.getContext("2d");
  deformationContext.fillStyle = "rgba(0,0,0,1)";
  deformationContext.fillRect(0,0,deformationCanvas.width,deformationCanvas.height);
  var gradient = deformationContext.createRadialGradient(100, 100, 0, 100, 100, 400);
  gradient.addColorStop(0, 'purple');
  gradient.addColorStop(.5, 'white');
  gradient.addColorStop(1, 'black');
  deformationContext.fillStyle = "#808";
  deformationContext.fillStyle = gradient;
  deformationContext.fillRect(3,5,deformationCanvas.width/1.2,deformationCanvas.height-100);
  console.log('filled');

  function recalculateDeformation() {
    movingTextureImage = $('#moving')[0];
    fixedTextureImage = $('#fixed')[0];
    deformationTextureImage = new Image();
    deformationTextureImage.src = deformationCanvas.toDataURL("image/png");
    setupInitialDeformationTexture(); // jvm - changes these to take image as parameter? change these to keep things as fields in image[i]?
    setupSourceTextures(); // jvm - changes these to take image as parameter? change these to keep things as fields in image[i]?
    setupFrameBuffers();
    compositeCanvas.height = movingTextureImage.height;
    compositeCanvas.width = movingTextureImage.width;
    render();
  };
  recalculateDeformation();

  // pass the mouse location as a uniform variable to the fragment shader
  var updateFocus = function(event) {
    var movingImage = $('#moving')[0];
    focusPoint = [event.offsetX / movingImage.width, 1. - (event.offsetY / movingImage.height)];
    render();
  };
  $('#compositeCanvas').mousedown(updateFocus);
  $('#compositeCanvas').mousemove(updateFocus);
  $('#compositeCanvas').mouseout(updateFocus);

  var drawStyle = "#F00";
  var drawing=false;
  function drawPoint (event) {
    if (drawing) {
      drawContext.strokeStyle = drawStyle;
      drawContext.fillStyle = drawStyle;
      drawContext.beginPath();
      drawContext.arc(event.offsetX, event.offsetY, 3, 0,2*Math.PI);
      drawContext.stroke();
      drawContext.fill();
      //redrawCompositeImage();
    }
  }
  $('.drawable').mousedown(function(event) {
    drawing=true;
    drawPoint(event);
  });
  $('.drawable').mousemove(function(event) {
    event.preventDefault();
    drawPoint(event);
    var continuousMode = true;
    if (continuousMode == true) {
      //redrawCompositeImage();
      recalculateDeformation();
    }
  });
  $('.drawable').mouseup(function(event) {
    drawing=false;
    recalculateDeformation();
  });
  $('.drawable').mouseout(function(event) {
    drawing=false;
    recalculateDeformation();
  });

  //
  // user interface elements
  //
  function updateParameters() {
    numberOfIterations = Number(document.getElementById('numberOfIterations').value);
    weight = Number(document.getElementById('weight').value);
    render();
  }

  // listen to continuous and release events
  // http://stackoverflow.com/questions/18544890/onchange-event-on-input-type-range-is-not-triggering-in-firefox-while-dragging
  document.getElementById('numberOfIterations').onchange = updateParameters;
  document.getElementById('weight').onchange = updateParameters;
  document.getElementById('numberOfIterations').oninput = updateParameters;
  document.getElementById('weight').oninput = updateParameters;
}

// once document is loaded, then load images, set up textures and framebuffers, and render
$(function () {
  var imagesLoaded = 0;
  function imageLoaded() {
    imagesLoaded++;
    console.log('loaded', imagesLoaded);
    if (imagesLoaded == 2) {
      setupInterface();
    }
  }
  $('#moving').load(imageLoaded);
  $('#fixed').load(imageLoaded);
});

</script>

<p>
Move pointer over the lower image. To the left of the mouse, the original intensity image is displayed with the pixels recolored to show the segmentation.
<br>
To the right of the mouse, the segmentation is shown above the mouse, while the strength image is shown below.
<br><br>
Check out <a href='https://github.com/pieper/sites/tree/gh-pages/glimp'>the source code</a>.
</p>

<p>
This demo uses WebGL.  Not all devices and browsers are supported.
</p>

</body>
</html>
